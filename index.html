<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
 
  <title>AR.js Octágonos Interactivos</title>
  <!-- A-Frame -->
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <!-- AR.js para A-Frame -->
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
  <style>
    body { margin: 0; overflow: hidden; }
    .hint { 
      position: fixed; 
      left: 0; 
      right: 0; 
      bottom: 0; 
      padding: 10px 12px; 
      font-family: system-ui, sans-serif; 
      background: rgba(0,0,0,.55); 
      color: #fff; 
      text-align: center; 
      z-index: 10; 
    }
    #patternMarker {
      display: none;
    }
  </style>
</head>
<body>
  <!-- Cambia este mensaje para que refleje tu imagen específica -->
  <div class="hint">Apunta a tu imagen personalizada. Toca un octágono para centrarlo y agrandarlo.</div>

  <!-- Patrón del marcador (debes reemplazar la URL con la de tu imagen) -->
  <!--<img id="patternMarker" src="https://raw.githubusercontent.com/AR-js-org/AR.js/master/data/images/hiro.png" alt="Pattern Marker">
  url de la camare
  url="https://raw.githubusercontent.com/AR-js-org/AR.js/master/data/images/hiro.patt" -->
  <img id="patternMarker" src="https://raw.githubusercontent.com/mago5560/mural-evos4hana/main/sdinicio.png" alt="Pattern Marker">

    <a-scene
      vr-mode-ui="enabled: false"
      renderer="antialias: true; colorManagement: true; precision: medium;"
      embedded
      arjs="trackingMethod: best; sourceType: webcam; debugUIEnabled: false;
            detectionMode: mono_and_matrix; matrixCodeType: 3x3;
            smoothing: true; smoothingCount: 5; smoothingTolerance: 0.01; smoothingThreshold: 2"
    >

    <!-- Añadimos un asset para el marcador de imagen -->
    <a-assets>
      <a-asset-item id="patternMarkerSrc" src="#patternMarker"></a-asset-item>
    </a-assets>

    <!-- Luz suave para resaltar los bordes -->
    <a-entity light="type: ambient; intensity: 0.8"></a-entity>
    <a-entity light="type: directional; intensity: 0.6" position="1 1 0"></a-entity>

    <!-- Marcador de imagen personalizado (reemplaza 'hiro' con tu patrón) -->
    <a-marker 
      type="pattern" 
      url="https://raw.githubusercontent.com/mago5560/mural-evos4hana/main/pattern-sdinicio.patt"
      raycaster="objects: .clickable"
      emitevents="true" 
      cursor="rayOrigin: mouse"
      id="marker">
      
      <!-- Contenedor de todos los octágonos -->
      <a-entity id="octagon-group" position="0 0 0">
        <a-gltf-model 
          src="#img-wally" 
          position="2 0.1 0" 
          scale="0.5 0.5 0.5" 
          rotation="0 90 0">
        </a-gltf-model>
        <a-gltf-model 
          src="#img-eva" 
          position="-2 0.1 0" 
          scale="0.5 0.5 0.5" 
          rotation="0 90 0">
        </a-gltf-model>
      </a-entity>
    </a-marker>

    <!-- Cámara y cursor basado en el puntero (soporta toque/pulsación) -->
    <a-entity camera look-controls>
      <a-cursor rayOrigin="mouse"></a-cursor>
    </a-entity>
    <!-- imagenes de sap,wally y eva -->
    </a-scene>
      <a-assets>
      <img id="img-sd" src="https://raw.githubusercontent.com/mago5560/mural-evos4hana/main/asset/SD.png" crossorigin="anonymous">
      <img id="img-pm" src="https://raw.githubusercontent.com/mago5560/mural-evos4hana/main/asset/PM.png" crossorigin="anonymous">
      <img id="img-co" src="https://raw.githubusercontent.com/mago5560/mural-evos4hana/main/asset/CO.png" crossorigin="anonymous">
      <img id="img-fi" src="https://raw.githubusercontent.com/mago5560/mural-evos4hana/main/asset/FI.png" crossorigin="anonymous">
      <img id="img-ewm" src="https://raw.githubusercontent.com/mago5560/mural-evos4hana/main/asset/EWM.png" crossorigin="anonymous">
      <img id="img-pp" src="https://raw.githubusercontent.com/mago5560/mural-evos4hana/main/asset/PP.png" crossorigin="anonymous">
      <img id="img-hcm" src="https://raw.githubusercontent.com/mago5560/mural-evos4hana/main/asset/HCM.png" crossorigin="anonymous">
      <img id="img-mm" src="https://raw.githubusercontent.com/mago5560/mural-evos4hana/main/asset/MM.png" crossorigin="anonymous">
      <img id="img-qm" src="https://raw.githubusercontent.com/mago5560/mural-evos4hana/main/asset/QM.png" crossorigin="anonymous">
      <img id="img-Aplicativos SD" src="https://raw.githubusercontent.com/mago5560/mural-evos4hana/main/asset/Apli_SD.png" crossorigin="anonymous">
      <a-asset-item id="img-wally" src="https://raw.githubusercontent.com/mago5560/mural-evos4hana/main/asset/WalleBot.glb"></a-asset-item>
      <a-asset-item id="img-eva" src="https://raw.githubusercontent.com/mago5560/mural-evos4hana/main/asset/EvaBot.glb"></a-asset-item>
      <img id="img-evolution" src="https://raw.githubusercontent.com/mago5560/mural-evos4hana/main/asset/evos4h.png" crossorigin="anonymous">
    </a-assets>
    <!-- hacemos que se mueva wally y eva como un la rotacion en un eje -->
   
  <script>
    
    // Ejecutar cuando la página y la cámara estén listas
    async function intentarForzarEnfoque() {
      try {
        // Busca el elemento video usado por el navegador (AR.js/A-Frame crea uno)
        const video = document.querySelector('video');
        if (!video) {
          console.warn('video no encontrado — intenta más tarde');
          return;
        }
  
        // Espera a que haya una pista de video activa
        const stream = video.srcObject || (video.captureStream ? video.captureStream() : null);
        const tracks = stream ? stream.getVideoTracks() : [];
        if (!tracks || tracks.length === 0) {
          console.warn('No hay pistas de video disponibles aún');
          return;
        }
  
        const track = tracks[0];
  
        // Revisa capacidades
        const caps = track.getCapabilities ? track.getCapabilities() : {};
        console.log('capabilities', caps);
  
        // Intentar modo continuo si está disponible
        if (caps.focusMode && caps.focusMode.includes('continuous')) {
          await track.applyConstraints({ advanced: [{ focusMode: 'continuous' }] });
          console.log('focusMode => continuous aplicado');
        } else if (caps.focusMode && caps.focusMode.includes('single-shot')) {
          // fallback: single-shot (se dispara al tocar)
          await track.applyConstraints({ advanced: [{ focusMode: 'single-shot' }] });
          console.log('focusMode => single-shot aplicado');
        } else {
          console.warn('focusMode no soportado por esta cámara');
        }
  
        // Añadir tap-to-focus: al tocar el video, dispara single-shot si está disponible
        video.addEventListener('click', async () => {
          try {
            if (caps.focusMode && caps.focusMode.includes('single-shot')) {
              await track.applyConstraints({ advanced: [{ focusMode: 'single-shot' }] });
              console.log('single-shot focus disparado (tap)');
            } else {
              // Alternativa: reenviar constraints para forzar ajuste de exposición/resolución
              await track.applyConstraints({ width: { ideal: 1280 }, height: { ideal: 720 } });
              console.log('applyConstraints para forzar reajuste');
            }
          } catch (err) {
            console.warn('Error al intentar tap-to-focus:', err);
          }
        });
  
      } catch (err) {
        console.error('Error configurar enfoque:', err);
      }
    }

    // Utilidad: crear un "octágono" como cilindro de 8 lados, muy delgado
    function createImage(id, position, src, scale = {x: 1, y: 1, z: 1}) {
      const img = document.createElement('a-image');
      img.setAttribute('id', id);
      img.classList.add('octagon');
      img.classList.add('clickable'); // Añadimos clase para interacción
      img.setAttribute('src', src); // Fuente de la imagen
      img.setAttribute('position', position);
      img.setAttribute('rotation', '-90 0 0'); // Rotación para que quede plana
      img.setAttribute('scale', `${scale.x} ${scale.y} ${scale.z}`);
      img.setAttribute('width', 0.6); // Ajusta el ancho de la imagen
      img.setAttribute('height', 0.4); // Ajusta el alto de la imagen
      return img;
    }

    const group = document.getElementById('octagon-group');
    // Octágono central inicial
    const centerId = 'octagon-center';
    const center = createImage(centerId, '0 0.1 0', '#img-evolution', {x:1.7, y:1.7, z:1.7})
    center.dataset.isCenter = 'true';
    group.appendChild(center);
    

    const imgSources = [
      '#img-sd', '#img-pm', '#img-co', '#img-fi', '#img-ewm',
      '#img-pp', '#img-hcm', '#img-mm', '#img-qm', '#img-Aplicativos SD'
    ];
 
    const R = 1.35; // radio del anillo
    const Y = 0.1;  // altura
    const count = 10;

    for (let i = 0; i < count; i++) {
      const theta = (i / count) * Math.PI * 2;
      const x = R * Math.cos(theta);
      const z = R * Math.sin(theta);
      const id = `image-${i+1}`;
      const img = createImage(id, `${x.toFixed(3)} ${Y} ${z.toFixed(3)}`, imgSources[i], {x: 1, y: 1, z: 1});
      group.appendChild(img);
    }

    // Animar transición suave
    function animateTo(entity, toPos, toScale, dur = 350) {
      entity.setAttribute('animation__pos', {
        property: 'position', to: toPos, dur, easing: 'easeInOutQuad'
      });
      entity.setAttribute('animation__scale', {
        property: 'scale', to: toScale, dur, easing: 'easeInOutQuad'
      });
    }

    function swapToCenter(target) {
      const currentCenter = group.querySelector('[data-is-center="true"]');
      if (!currentCenter || target === currentCenter) return;

      // Posiciones/escala
      const targetOriginalPos = target.getAttribute('position');
      const centerOriginalPos = currentCenter.getAttribute('position');

      const targetOriginalSlot = target.dataset.originalPosition || `${targetOriginalPos.x} ${targetOriginalPos.y} ${targetOriginalPos.z}`;
      const centerScaleSmall = '1 1 1';
      const bigScale = '1.7 1.7 1.7';

      // 1) Mover el target al centro y agrandarlo
      animateTo(target, '0 0.1 0', bigScale);
      target.dataset.isCenter = 'true';

      // 2) Mover el que estaba al centro hacia el lugar original del target y hacerlo pequeño
      animateTo(currentCenter, targetOriginalSlot, centerScaleSmall);
      delete currentCenter.dataset.isCenter;

      // 3) Actualizar data-originalPosition: el que sale al anillo hereda el slot del target
      currentCenter.dataset.originalPosition = targetOriginalSlot;
    }

    // Interacción: tocar/click sobre cualquier octágono del anillo
    group.addEventListener('click', (ev) => {
      const t = ev.target;
      if (!t.classList || !t.classList.contains('octagon')) return;
      if (t.dataset.isCenter === 'true') return;
      swapToCenter(t);
    });

    // Evitar que el tap arrastre la escena en móviles
    document.body.addEventListener('touchmove', (e) => { e.preventDefault(); }, { passive: false });
    
      const centerPosition = { x: 0, y: 0.1, z: 0 }; 
      const innerRadius = 0.75;   // Radio cuando están adentro
      const outerRadius = 2.5;   // Radio cuando se salen afuera
      const speed = 0.01;

      const eva = document.querySelector('[src="#img-eva"]');
      const wally = document.querySelector('[src="#img-wally"]');

      let angleEva = 0; 
      let angleWally = Math.PI; 
      let evaAfuera = false; 
      let wallyAfuera = false; 
      // Función que actualiza las posiciones de Eva y Wally
      const updatePositions = () => {
        
        if (!evaAfuera){
          const evaX = centerPosition.x + innerRadius * Math.cos(angleEva);
          const evaZ = centerPosition.z + innerRadius * Math.sin(angleEva);
          eva.setAttribute('position', `${evaX} ${centerPosition.y} ${evaZ}`);
          angleEva += speed;
        } else {
          const evaX = centerPosition.x + outerRadius * Math.cos(angleEva);
          const evaZ = centerPosition.z + outerRadius * Math.sin(angleEva);
          eva.setAttribute('position', `${evaX} ${centerPosition.y} ${evaZ}`);
          angleEva += 0.03;
        }
        
        // Wally
        if (!wallyAfuera) {
          const wallyX = centerPosition.x + innerRadius * Math.cos(angleWally);
          const wallyZ = centerPosition.z + innerRadius * Math.sin(angleWally);
          wally.setAttribute('position', `${wallyX} ${centerPosition.y} ${wallyZ}`);
          angleWally += speed;
        } else {
          const wallyX = centerPosition.x + outerRadius * Math.cos(angleWally);
          const wallyZ = centerPosition.z + outerRadius * Math.sin(angleWally);
          wally.setAttribute('position', `${wallyX} ${centerPosition.y} ${wallyZ}`);
          angleWally += 0.03;
        }

        requestAnimationFrame(updatePositions);
      };

      // Inicia animación
      updatePositions();
      
      //alternar eva adentro/afuera con un click
      const posicionEva = () => {
        evaAfuera = !evaAfuera;
      };
      //alternar wally adentro/afuera con un click
      const posicionWally = () => {
        wallyAfuera = !wallyAfuera;
      };
      eva.addEventListener('click', posicionEva);
      wally.addEventListener('click', posicionWally);

  </script>
</body>

</html>

